{
    "run_id": "D",
    "status": "SUCCESS_RETRO",
    "quality_analysis": {
        "total_score": 100,
        "scores": {
            "security": 40,
            "readability": 30,
            "performance": 30
        },
        "details": {
            "security": "SecurityReport(success=True, highest_severity=None, issues=[], error_message=None)",
            "readability": "ReadabilityReport(success=True, average_complexity=3.4, complexities=[{'type': 'method', 'rank': 'C', 'lineno': 209, 'col_offset': 4, 'complexity': 11, 'classname': 'QDPReader', 'endline': 268, 'name': '_build_table', 'closures': []}, {'type': 'method', 'rank': 'B', 'lineno': 83, 'col_offset': 4, 'complexity': 6, 'classname': 'QDPReader', 'endline': 119, 'name': '_parse_line', 'closures': []}, {'type': 'class', 'rank': 'A', 'lineno': 18, 'col_offset': 0, 'complexity': 5, 'endline': 268, 'name': 'QDPReader', 'methods': [{'type': 'method', 'rank': 'A', 'lineno': 43, 'col_offset': 4, 'complexity': 1, 'classname': 'QDPReader', 'endline': 54, 'name': '__init__', 'closures': []}, {'type': 'method', 'rank': 'A', 'lineno': 59, 'col_offset': 4, 'complexity': 2, 'classname': 'QDPReader', 'endline': 78, 'name': 'read', 'closures': []}, {'type': 'method', 'rank': 'B', 'lineno': 83, 'col_offset': 4, 'complexity': 6, 'classname': 'QDPReader', 'endline': 119, 'name': '_parse_line', 'closures': []}, {'type': 'method', 'rank': 'A', 'lineno': 124, 'col_offset': 4, 'complexity': 1, 'classname': 'QDPReader', 'endline': 140, 'name': '_handle_read', 'closures': []}, {'type': 'method', 'rank': 'A', 'lineno': 142, 'col_offset': 4, 'complexity': 3, 'classname': 'QDPReader', 'endline': 172, 'name': '_handle_read_serr', 'closures': []}, {'type': 'method', 'rank': 'A', 'lineno': 174, 'col_offset': 4, 'complexity': 3, 'classname': 'QDPReader', 'endline': 204, 'name': '_handle_read_terr', 'closures': []}, {'type': 'method', 'rank': 'C', 'lineno': 209, 'col_offset': 4, 'complexity': 11, 'classname': 'QDPReader', 'endline': 268, 'name': '_build_table', 'closures': []}]}, {'type': 'method', 'rank': 'A', 'lineno': 142, 'col_offset': 4, 'complexity': 3, 'classname': 'QDPReader', 'endline': 172, 'name': '_handle_read_serr', 'closures': []}, {'type': 'method', 'rank': 'A', 'lineno': 174, 'col_offset': 4, 'complexity': 3, 'classname': 'QDPReader', 'endline': 204, 'name': '_handle_read_terr', 'closures': []}, {'type': 'method', 'rank': 'A', 'lineno': 59, 'col_offset': 4, 'complexity': 2, 'classname': 'QDPReader', 'endline': 78, 'name': 'read', 'closures': []}, {'type': 'function', 'rank': 'A', 'lineno': 273, 'col_offset': 0, 'complexity': 1, 'endline': 291, 'name': 'read_qdp', 'closures': []}, {'type': 'class', 'rank': 'A', 'lineno': 10, 'col_offset': 0, 'complexity': 1, 'endline': 11, 'name': 'QDPError', 'methods': []}, {'type': 'method', 'rank': 'A', 'lineno': 43, 'col_offset': 4, 'complexity': 1, 'classname': 'QDPReader', 'endline': 54, 'name': '__init__', 'closures': []}, {'type': 'method', 'rank': 'A', 'lineno': 124, 'col_offset': 4, 'complexity': 1, 'classname': 'QDPReader', 'endline': 140, 'name': '_handle_read', 'closures': []}], error_message=None)",
            "performance": "PerformanceReport(success=True, original_avg_time=3.999999999837467e-07, modified_avg_time=1.0000000000287557e-07, improvement_percentage=74.99999999826528, error_message=None)"
        }
    },
    "functional_analysis": {
        "success": true,
        "message": "Execution Successful (Docker)"
    },
    "architect_plan": {
        "work_order_id": "WO-qdp-001",
        "synthesis_goal": "Resolve Issue",
        "reasoning_log": "[Phase 1] Goal is 'Resolve Issue', i.e., ensure QDP directives are handled case-insensitively and behavior matches the described expectation. Expert suggestions are mostly generic; none reference the concrete QDPReader code structure directly. [Phase 2] All performance suggestions target broad ranges (main.py#L1-L220) and are not tied to specific constructs in this small file; readability suggestions are likewise generic. No overlapping, concrete conflict points on specific lines of the actual implementation are detected. [Phase 3] No SecurityExpert report was provided, so there are no Critical security directives to prioritize. Unit tests are N/A, so functionality preservation is enforced via careful reasoning: the current implementation already provides case-insensitive command parsing via `upper_line = line_stripped.upper()` and dispatch on `READ`, `READ SERR`, and `READ TERR`, directly addressing the original bug description. Performance suggestions PERF-001..005 are generic templates and not applicable to the concrete, simple logic here without inventing new behavior, so they are rejected under the Functionality Preservation and Minimal Invasiveness principles. READ-001 requests more source, which is outside the scope of code refactoring; READ-002 and READ-005 are not concretely triggered (no Any, no complex comprehensions), so are ignored. [Phase 4] Remaining relevant suggestion is READ-004: add docstrings to public APIs. This is fully compatible with the existing logic and does not change behavior, so it can be safely integrated with minimal invasiveness to improve maintainability. No conflicts arise. [Phase 5] Execution order: a single non-functional change is neededâ€”augment public APIs (QDPReader and read_qdp) with clear docstrings, reusing and slightly clarifying the existing comments while preserving all semantics. [Phase 6] Final plan: one REPLACE action that only adds or refines docstrings, with SIMPLE_MODIFICATION replacement_code including the full updated file. This respects the constitutional constraints (no critical security changes needed, functionality preserved, minimal yet useful readability improvement).",
        "instructions": [
            {
                "step": 1,
                "description": "Add and refine docstrings for the public QDPReader class and read_qdp function to clearly document purpose, parameters, return values, and behavior, without altering logic.",
                "action": "REPLACE",
                "target_code_block": "main.py#L1-L220",
                "new_code": null,
                "details": {
                    "refactor_type": "SIMPLE_MODIFICATION",
                    "replacement_code": "import os\nfrom typing import List, Optional, Tuple\n\nimport numpy as np\n\nfrom astropy.io import ascii\nfrom astropy.table import Table, Column\n\n\nclass QDPError(Exception):\n    \"\"\"Custom exception for QDP parsing errors.\n\n    Raised when a QDP file cannot be parsed according to the limited\n    functionality implemented by :class:`QDPReader`.\n    \"\"\"\n\n\nclass QDPReader:\n    \"\"\"Simple QDP file reader with basic support for READ, READ SERR, and READ TERR.\n\n    This lightweight reader is a minimal stand-in that implements just\n    enough of the QDP parsing behavior to exercise regression tests for\n    case-insensitive command parsing. In the real Astropy codebase, the\n    corresponding logic lives in :mod:`astropy.io.ascii.qdp` and provides a\n    more feature-complete implementation.\n\n    The key behavior illustrated here is that QDP directive recognition is\n    performed in a *case-insensitive* way, so commands such as ``READ``,\n    ``READ SERR``, and ``READ TERR`` are accepted regardless of their\n    capitalization (e.g., ``read serr 1 2``).\n\n    Notes\n    -----\n    * Data lines (non-directive, non-comment lines) are interpreted as\n      whitespace-separated numeric columns.\n    * ``READ SERR i j`` assumes symmetric errors are provided in the\n      immediate next columns for the specified value columns.\n    * ``READ TERR`` handling is included only as a placeholder and mirrors\n      the dispatch style of ``READ SERR`` but is not fully exercised by the\n      regression tests.\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize an empty QDPReader instance.\n\n        The reader maintains internal state describing the current READ\n        mode (plain values, symmetric errors, or placeholder for\n        asymmetric errors), along with any configured column indices for\n        error handling.\n        \"\"\"\n        self._data_lines: List[str] = []\n        self._read_mode: str = \"READ\"  # \"READ\", \"READ_SERR\", or \"READ_TERR\"\n        self._serr_cols: Tuple[int, int] = ()\n        self._terr_cols: Tuple[int, int] = ()\n\n    # ------------------------------------------------------------------\n    # Public API\n    # ------------------------------------------------------------------\n    def read(self, filename: str) -> Table:\n        \"\"\"Read a QDP file from disk and return its contents as a Table.\n\n        Parameters\n        ----------\n        filename : str\n            Path to the QDP file to be read.\n\n        Returns\n        -------\n        astropy.table.Table\n            A table containing the numeric data from the QDP file. Column\n            names follow a simple convention: ``c1``, ``c2``, ... for value\n            columns, with additional columns such as ``c1err`` appended when\n            symmetric error columns are present via ``READ SERR``.\n        \"\"\"\n        with open(filename, \"r\") as fh:\n            for raw_line in fh:\n                self._parse_line(raw_line)\n        return self._build_table()\n\n    # ------------------------------------------------------------------\n    # Line parsing\n    # ------------------------------------------------------------------\n    def _parse_line(self, line: str) -> None:\n        \"\"\"Parse a single line from a QDP file.\n\n        This method implements case-insensitive recognition of QDP\n        directives. Comment lines (starting with ``!``) and blank lines are\n        ignored. Any non-directive, non-comment lines are treated as table\n        data and stored for later conversion into numeric rows.\n\n        Parameters\n        ----------\n        line : str\n            Raw line read from the QDP file, including any trailing\n            newline characters.\n        \"\"\"\n\n        line_stripped = line.strip()\n        if not line_stripped or line_stripped.startswith(\"!\"):\n            # Blank or comment\n            return\n\n        # Directives in QDP are case-insensitive. Normalize only for\n        # directive recognition; keep the original for downstream parsing.\n        upper_line = line_stripped.upper()\n\n        # Recognized commands. Only a small subset is supported here, but\n        # the key point is that the matching is case-insensitive.\n        if upper_line.startswith(\"READ SERR\"):\n            self._handle_read_serr(line_stripped)\n        elif upper_line.startswith(\"READ TERR\"):\n            self._handle_read_terr(line_stripped)\n        elif upper_line.startswith(\"READ\"):\n            self._handle_read(line_stripped)\n        else:\n            # If it's not a recognized directive, treat it as data.\n            # This mirrors the behavior of a typical QDP parser where\n            # non-command, non-comment lines are table rows.\n            self._data_lines.append(line_stripped)\n\n    # ------------------------------------------------------------------\n    # Command handlers\n    # ------------------------------------------------------------------\n    def _handle_read(self, line: str) -> None:\n        \"\"\"Handle a generic ``READ`` directive.\n\n        For this minimal implementation we only switch to plain ``READ``\n        mode and do not interpret additional options in the directive\n        itself.\n\n        Parameters\n        ----------\n        line : str\n            The directive line, as read (preserving original case).\n        \"\"\"\n\n        self._read_mode = \"READ\"\n        # No column index specification for basic READ.\n        self._serr_cols = ()\n        self._terr_cols = ()\n\n    def _handle_read_serr(self, line: str) -> None:\n        \"\"\"Handle a ``READ SERR`` directive.\n\n        QDP syntax is typically ``READ SERR i j`` where ``i`` and ``j`` are\n        1-based indices of the *value* columns that have symmetric errors\n        provided in subsequent columns of the data.\n\n        Parameters\n        ----------\n        line : str\n            The directive line, as read (case preserved).\n\n        Raises\n        ------\n        QDPError\n            If fewer than two column indices are supplied or if the\n            indices cannot be parsed as integers.\n        \"\"\"\n\n        self._read_mode = \"READ_SERR\"\n        tokens = line.split()\n        # Expected forms like: READ SERR 1 2   (possibly with extra args)\n        if len(tokens) < 4:\n            raise QDPError(f\"READ SERR directive requires at least two column indices: {line}\")\n        try:\n            # 1-based indices of value columns with errors\n            i = int(tokens[2])\n            j = int(tokens[3])\n        except ValueError as exc:\n            raise QDPError(f\"Invalid column indices in READ SERR directive: {line}\") from exc\n        self._serr_cols = (i, j)\n\n    def _handle_read_terr(self, line: str) -> None:\n        \"\"\"Handle a ``READ TERR`` directive.\n\n        This is provided mainly for completeness and to mirror the\n        case-insensitive dispatch style of :meth:`_handle_read_serr`. The\n        current minimal implementation records the specified value column\n        indices but does not construct explicit asymmetric error columns in\n        the output table.\n\n        Parameters\n        ----------\n        line : str\n            The directive line, as read (case preserved).\n\n        Raises\n        ------\n        QDPError\n            If fewer than two column indices are supplied or if the\n            indices cannot be parsed as integers.\n        \"\"\"\n\n        self._read_mode = \"READ_TERR\"\n        tokens = line.split()\n        if len(tokens) < 4:\n            raise QDPError(f\"READ TERR directive requires at least two column indices: {line}\")\n        try:\n            i = int(tokens[2])\n            j = int(tokens[3])\n        except ValueError as exc:\n            raise QDPError(f\"Invalid column indices in READ TERR directive: {line}\") from exc\n        self._terr_cols = (i, j)\n\n    # ------------------------------------------------------------------\n    # Table construction\n    # ------------------------------------------------------------------\n    def _build_table(self) -> Table:\n        \"\"\"Build an :class:`~astropy.table.Table` from collected data lines.\n\n        Returns\n        -------\n        astropy.table.Table\n            A table with one column per numeric field in the data lines.\n            Column names are ``c1``, ``c2``, ... for value columns, with\n            additional ``cNerr`` columns appended when symmetric error\n            handling via ``READ SERR`` has been requested.\n\n        Raises\n        ------\n        QDPError\n            If non-numeric data are encountered in a data row or if there\n            are insufficient columns available for the configured symmetric\n            error columns.\n        \"\"\"\n        if not self._data_lines:\n            return Table()\n\n        # Split all data lines into numeric tokens\n        rows: List[List[float]] = []\n        for ln in self._data_lines:\n            if not ln:\n                continue\n            try:\n                row = [float(tok) for tok in ln.split()]\n            except ValueError as exc:\n                raise QDPError(f\"Non-numeric data in QDP table row: {ln}\") from exc\n            rows.append(row)\n\n        arr = np.array(rows, dtype=float)\n        ncols = arr.shape[1]\n\n        # Build base value columns: c1, c2, ...\n        cols: List[Column] = []\n        for i in range(ncols):\n            cols.append(Column(arr[:, i], name=f\"c{i+1}\"))\n\n        # Attach symmetric error columns if requested.\n        if self._read_mode == \"READ_SERR\" and self._serr_cols:\n            # QDP convention: for each value column that has symmetric\n            # errors, the next column in the data contains its error.\n            # Here we mirror that simplified mapping.\n            for idx in self._serr_cols:\n                val_col_idx = idx - 1  # 1-based to 0-based\n                err_col_idx = val_col_idx + 1\n                if err_col_idx >= ncols:\n                    raise QDPError(\n                        \"Not enough columns for symmetric errors: \"\n                        f\"value column {idx} has no corresponding error column.\"\n                    )\n                err_name = f\"c{idx}err\"\n                cols.append(Column(arr[:, err_col_idx], name=err_name))\n\n        # NOTE: READ_TERR handling is omitted for brevity; similar logic\n        # would be added for asymmetric errors.\n\n        return Table(cols)\n\n\n# Convenience function mimicking Table.read(..., format='ascii.qdp')\n\ndef read_qdp(filename: str) -> Table:\n    \"\"\"Read a QDP file and return its contents as an Astropy Table.\n\n    This is a convenience wrapper around :class:`QDPReader` intended to\n    mimic the user-facing behavior of ``Table.read(..., format='ascii.qdp')``\n    for the limited feature set implemented here.\n\n    Parameters\n    ----------\n    filename : str\n        Path to the QDP file to be read.\n\n    Returns\n    -------\n    astropy.table.Table\n        The parsed table constructed from the QDP file.\n    \"\"\"\n    reader = QDPReader()\n    return reader.read(filename)\n"
                },
                "source_suggestion_ids": [
                    "READ-004"
                ],
                "rationale": "Applying READ-004 improves documentation of the public API without altering logic, satisfying the Minimal Invasiveness and Functionality Preservation principles while the core issue (case-insensitive handling of READ/READ SERR/READ TERR) is already correctly implemented."
            }
        ]
    },
    "developer_log": [
        "Step 1: Replaced main.py contents with updated version containing refined and expanded docstrings for QDPError, QDPReader, and read_qdp, preserving all existing logic and behavior."
    ],
    "feedback_used": "NFR Score Low (70).",
    "cost_analysis": {
        "prompt_tokens": 24934,
        "completion_tokens": 11122,
        "estimated_cost_usd": 0.2915
    },
    "maestro_score": 100
}