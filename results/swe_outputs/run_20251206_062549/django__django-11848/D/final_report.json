{
    "run_id": "D",
    "status": "SUCCESS_RETRO",
    "quality_analysis": {
        "total_score": 0,
        "scores": {
            "security": 0,
            "readability": 0,
            "performance": 0
        },
        "details": {
            "error": "SyntaxError: unexpected character after line continuation character line 16"
        }
    },
    "functional_analysis": {
        "success": false,
        "message": "SyntaxError in generated code: unexpected character after line continuation character at line 16"
    },
    "architect_plan": {
        "work_order_id": "WO-parse-http-date-rfc850-2digit-fix-001",
        "synthesis_goal": "Resolve Issue",
        "reasoning_log": "[Phase 1] Goal is 'Resolve Issue': fix django.utils.http.parse_http_date two-digit RFC 850 year handling per RFC 7231 sliding window. Expert performance/readability reports are generic and not specific to this code; none mention parse_http_date. No unit tests are provided, so functionality preservation is ensured by keeping changes minimal and localized. [Phase 2] All expert suggestions target broad/unknown ranges, not the specific parse_http_date implementation, so there are no concrete conflict points on the target function. [Phase 3] No SecurityExpert reports are present; thus no Critical security items to apply. Performance suggestions are hypothetical and not applicable to the current code. Readability suggestions are also generic and not tied to actual locations. They are ignored to avoid invasive, speculative refactoring. [Phase 4] Focus is entirely on the functional bug: currently, parsedate_tz already expands two-digit years using a fixed 1900/2000 split. To comply with RFC 7231's 50-year sliding window, we must override that behavior only for RFC 850-style two-digit years and leave all other formats unchanged. We design a heuristic to detect RFC 850 two-digit patterns from the original date string and then remap the resulting year relative to the current year when it's within 0â€“99. This avoids breaking other date formats and preserves backward compatibility as much as possible. [Phase 5] Execution order: a single REPLACE action on parse_http_date, reusing the existing public API and behavior except for the two-digit RFC 850 case. We keep all other functions intact. [Phase 6] Final plan: one precise modification of parse_http_date that (a) calls parsedate_tz, (b) heuristically detects RFC 850 two-digit dates, (c) applies the RFC 7231 50-year sliding window only in that case, and (d) returns the same integer timestamp semantics as before. This minimizes invasiveness while resolving the specified issue.",
        "instructions": [
            {
                "step": 1,
                "description": "Refactor parse_http_date to correctly handle RFC 850 two-digit years using RFC 7231 50-year sliding window while preserving existing behavior for other formats.",
                "action": "REPLACE",
                "target_code_block": "main.py#parse_http_date",
                "new_code": null,
                "details": {
                    "refactor_type": "SIMPLE_MODIFICATION",
                    "replacement_code": "def parse_http_date(date):\n    \"\"\"Parse an HTTP-date as defined by RFC 7231 section 7.1.1.1.\n\n    Supported formats:\n    * RFC 1123: 'Sun, 06 Nov 1994 08:49:37 GMT'\n    * RFC 850:  'Sunday, 06-Nov-94 08:49:37 GMT'\n    * asctime:  'Sun Nov  6 08:49:37 1994'\n\n    For RFC 850 dates using a two-digit year, this function interprets the\n    year according to RFC 7231: any resulting year that would be more than\n    50 years in the future is instead mapped to the most recent past year\n    that has the same last two digits.\n    \"\"\"\n    if date is None:\n        return None\n\n    # First, try the standard library parser to get a 9-tuple + offset.\n    timetuple = parsedate_tz(date)\n    if timetuple is None:\n        return None\n\n    # timetuple: (year, month, day, hour, minute, second, wday, yday, dst, tzoffset)\n    year, month, day, hour, minute, second, wday, yday, dst, tzoffset = timetuple\n\n    # Detect RFC 850 two-digit year format from the original string.\n    # RFC 850 example: 'Sunday, 06-Nov-94 08:49:37 GMT'\n    # Heuristic: original string has a comma followed by a space (weekday),\n    # and a hyphen-separated day-month-year part whose year is exactly two digits.\n    is_rfc850_two_digit = False\n    try:\n        if \",\" in date:\n            after_comma = date.split(\",\", 1)[1].strip()\n            # Expect something like '06-Nov-94 ...'\n            date_part = after_comma.split(\" \", 1)[0]\n            parts = date_part.split(\"-\")\n            if len(parts) == 3 and len(parts[2]) == 2:\n                is_rfc850_two_digit = True\n    except Exception:\n        # On any heuristic failure, fall back to non-RFC850 handling.\n        is_rfc850_two_digit = False\n\n    if is_rfc850_two_digit and 0 <= year <= 99:\n        # Apply RFC 7231 50-year sliding window for two-digit years.\n        # We interpret the parsed 0-99 year as the last two digits of a\n        # full year that is not more than 50 years in the future relative\n        # to the current year. If the naive candidate in the current\n        # century is more than 50 years ahead, roll back 100 years to get\n        # the most recent past year with the same last two digits.\n        current_year = datetime.date.today().year\n        yy = year\n        base_century = current_year - (current_year % 100)\n        candidate = base_century + yy\n        if candidate - current_year > 50:\n            candidate -= 100\n        year = candidate\n\n    try:\n        dt = datetime.datetime(year, month, day, hour, minute, second)\n    except (OverflowError, ValueError):\n        return None\n\n    if tzoffset is None:\n        # Assume UTC if no timezone is provided, per RFC 7231 HTTP-date semantics.\n        tzoffset = 0\n\n    timestamp = int((dt - datetime.datetime(1970, 1, 1)).total_seconds()) - tzoffset\n    return timestamp\n"
                },
                "source_suggestion_ids": [],
                "rationale": "Directly addresses the reported issue by implementing RFC 7231-compliant interpretation of RFC 850 two-digit years while keeping changes localized to parse_http_date, in line with the Principles of Functionality Preservation and Minimal Invasiveness."
            }
        ]
    },
    "developer_log": [
        "Step 1: Replaced parse_http_date with RFC 7231-compliant implementation using a 50-year sliding window for RFC 850 two-digit years while preserving behavior for other formats."
    ],
    "feedback_used": "Functional Error: SyntaxError in generated code: unexpected character after line continuation character at line 16\nNFR Score Low (0).",
    "cost_analysis": {
        "prompt_tokens": 25998,
        "completion_tokens": 10637,
        "estimated_cost_usd": 0.289545
    },
    "maestro_score": 0
}